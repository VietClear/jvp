<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>VietClear</title>

    <!-- iOS PWA fullscreen support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="VietClear">
    <link rel="apple-touch-icon" href="/assets/icons/icon-192.png">

    <!-- Manifest (needed for standalone launch on iOS/Android) -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#009688">

    <!-- Handwritten title font (English title only) -->
    <link href="https://fonts.googleapis.com/css2?family=Handlee&display=swap" rel="stylesheet">

    <style>
        :root {
            --fg: #111;
            --bg: #FAFAFA;
            --muted: #666;

            /* Primary = App audio (teal) */
            --accent: #009688;
            --accent-hover: #00897B;
            --accent-press: #00796B;

            /* Secondary = My attempt (orange) */
            --secondary: #FF7043;
            --secondary-hover: #F7673C;
            --secondary-press: #E85E30;

            --card: #ffffff;
            --border: #e5e5e5;
            --pressed: #eef6f5;
            --focus: rgba(0, 150, 136, 0.28);
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            margin: 0;
            padding: 0
        }

        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
            color: var(--fg);
            background: var(--bg);
            line-height: 1.45;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Header */
        .app-header {
            position: sticky;
            top: 0;
            z-index: 20;
            background: var(--bg);
            border-bottom: 1px solid var(--border);
            padding: 8px 12px;
            -webkit-user-select: none;
            user-select: none;
        }

        .app-title {
            font-family: 'Handlee', cursive;
            font-size: 22px;
            margin: 0;
            text-align: center;
        }

        main#app {
            max-width: 960px;
            margin: 0 auto;
            padding: 12px;
        }

        /* Views */
        .view {
            display: none;
        }

        .view.active {
            display: block;
        }

        .view-header {
            display: flex;
            justify-content: center;
            padding: 8px 0 12px;
            position: sticky;
            top: 56px;
            background: var(--bg);
            z-index: 15;
            border-bottom: 1px solid var(--border);
        }

        /* Buttons */
        .btn,
        .audio-btn {
            border: 1px solid var(--border);
            background: var(--card);
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color .12s ease, filter .12s ease, transform .08s ease, box-shadow .12s ease, border-color .12s ease, color .12s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .btn:hover,
        .audio-btn:hover {
            filter: brightness(.98)
        }

        .btn:active,
        .audio-btn:active {
            background: var(--pressed)
        }

        .btn:focus-visible,
        .audio-btn:focus-visible {
            outline: none;
            box-shadow: 0 0 0 3px var(--focus)
        }

        /* Primary (App audio) */
        .btn.primary,
        .audio-btn.primary {
            background: var(--accent);
            color: #fff;
            border-color: var(--accent);
        }

        .btn.primary:hover,
        .audio-btn.primary:hover {
            background: var(--accent-hover);
            border-color: var(--accent-hover);
        }

        .btn.primary:active,
        .audio-btn.primary:active {
            background: var(--accent-press);
            border-color: var(--accent-press);
        }

        .audio-btn[aria-busy="true"] {
            opacity: .75;
            pointer-events: none;
        }

        .audio-btn.primary.playing {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }

        /* Secondary (My attempt) */
        .btn.my-attempt.playing {
            background: var(--secondary);
            border-color: var(--secondary);
            color: #fff;
        }

        .btn.my-attempt.secondary {
            background: var(--secondary);
            border-color: var(--secondary);
            color: #fff;
        }

        .btn.my-attempt.secondary:hover {
            background: var(--secondary-hover);
            border-color: var(--secondary-hover);
        }

        .btn.my-attempt.secondary:active {
            background: var(--secondary-press);
            border-color: var(--secondary-press);
        }

        .btn.back {
            min-width: 180px;
            font-weight: 700;
            padding: 12px 16px;
            border-radius: 14px;
        }

        .btn.ghost {
            background: transparent;
            color: var(--muted)
        }

        .btn.is-pressed,
        .audio-btn.is-pressed,
        .syllable.is-pressed {
            transform: scale(.98);
            box-shadow: 0 0 0 2px var(--pressed) inset;
        }

        /* Categories grid */
        .category-list {
            list-style: none;
            padding: 0;
            margin: 10px 0 0;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(190px, 1fr));
            gap: 12px;
        }

        .category-list li {
            border: 1px solid var(--border);
            background: var(--card);
            border-radius: 14px;
            padding: 16px;
            cursor: pointer;
            transition: filter .12s ease, background-color .12s ease;
        }

        .category-list li:hover {
            filter: brightness(.98)
        }

        .category-list li:active {
            background: var(--pressed)
        }

        .category-name {
            display: block;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .category-count {
            color: var(--muted);
            font-size: 13px;
        }

        .category-title {
            text-align: center;
            margin: 14px 0;
            font-size: 18px;
        }

        /* Tone Guide card in Categories */
        .tone-guide-card {
            border: 1px dashed var(--accent);
            background: #fff;
        }

        /* Phrases list */
        .phrases-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }

        .phrase-card {
            border: 1px solid var(--border);
            background: var(--card);
            border-radius: 14px;
            padding: 12px;
        }

        .phrase-top {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .audio-btn {
            display: inline-block;
            border: 1px solid var(--border);
            background: var(--card);
            border-radius: 8px;
            padding: 6px 10px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color .12s ease, filter .12s ease, transform .08s ease, box-shadow .12s ease, border-color .12s ease, color .12s ease;
            -webkit-tap-highlight-color: transparent;
        }

        /* Syllables */
        .syllable-row {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 8px;
            margin-top: 8px;
        }

        .syllable {
            border: 1px dashed var(--border);
            border-radius: 10px;
            padding: 8px;
            display: grid;
            grid-template-rows: auto auto;
            gap: 4px;
            background: #fff;
            cursor: pointer;
            transition: background-color .12s ease, filter .12s ease, transform .08s ease, box-shadow .12s ease, border-color .12s ease, color .12s ease;
        }

        .syllable:focus-visible {
            outline: none;
            box-shadow: 0 0 0 3px var(--focus)
        }

        .syllable .syllable-head {
            display: flex;
            align-items: baseline;
            gap: 6px;
        }

        .syllable .syllable-text {
            font-size: 18px;
            font-weight: 700;
        }

        .syllable .play-hint {
            font-size: 12px;
            color: var(--muted);
            line-height: 1;
            user-select: none;
        }

        .syllable .tone-name {
            font-size: 12px;
            color: var(--muted);
        }

        /* Translation (English) — moved ABOVE Vietnamese per spec */
        .translation {
            margin: 2px 0 8px;
            color: var(--muted);
            font-size: 14px;
            font-style: italic;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }

        .note {
            color: var(--muted);
            font-size: 13px;
        }

        .visually-hidden {
            position: absolute !important;
            height: 1px;
            width: 1px;
            overflow: hidden;
            clip: rect(1px, 1px, 1px, 1px);
            white-space: nowrap;
            border: 0;
            padding: 0;
            margin: -1px;
        }

        @media (max-width:480px) {
            .syllable-row {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }
    </style>
</head>

<body>
    <header class="app-header">
        <h1 class="app-title">VietClear</h1>
    </header>

    <main id="app">
        <!-- View: Categories (DEFAULT) -->
        <section id="view-categories" class="view active" aria-label="Categories">
            <h2 class="visually-hidden">Categories</h2>
            <ul id="categoryList" class="category-list"></ul>
        </section>

        <!-- View: Phrases -->
        <section id="view-phrases" class="view" aria-label="Phrases" hidden>
            <div class="view-header">
                <button id="btnBackToCategories" class="btn back">Categories</button>
            </div>
            <h2 id="phrasesCategoryTitle" class="category-title"></h2>
            <div id="phrasesContainer" class="phrases-container"></div>
        </section>
    </main>

    <script>
        // =========================
        // ID-based mapping (no slugifying)
        // =========================

        /** Global mapping loaded from /assets/mapping.json */
        let MAPPING = null;

        async function initMapping() {
            try {
                const res = await fetch('assets/mapping.json', { cache: 'no-store' });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                MAPPING = await res.json();
            } catch (err) {
                console.error('Failed to load mapping.json', err);
                MAPPING = { categories: [], phrases: {} };
            }
        }

        // Simple player with visual feedback.
        let CURRENT_AUDIO = null;
        let CURRENT_BTN = null;

        function stopCurrentAudio() {
            if (CURRENT_AUDIO) {
                try { CURRENT_AUDIO.pause(); CURRENT_AUDIO.currentTime = 0; } catch { }
                CURRENT_AUDIO = null;
            }
            if (CURRENT_BTN) {
                CURRENT_BTN.classList.remove('playing');
                CURRENT_BTN.removeAttribute('aria-busy');
                CURRENT_BTN = null;
            }
        }

        function playById(id, btn) {
            try {
                stopCurrentAudio();
                const audio = new Audio(`assets/audio/${id}.mp3`);
                CURRENT_AUDIO = audio;
                CURRENT_BTN = btn || null;
                if (CURRENT_BTN) {
                    CURRENT_BTN.classList.add('playing');
                    CURRENT_BTN.setAttribute('aria-busy', 'true');
                }
                audio.addEventListener('ended', stopCurrentAudio, { once: true });
                audio.addEventListener('error', stopCurrentAudio, { once: true });
                audio.play();
            } catch (e) {
                console.warn('Audio failed for id:', id, e);
                stopCurrentAudio();
            }
        }

        // =========================
        // Record & Compare (phrase-level, temporary)
        // =========================
        const RECORDINGS = new Map();
        let ACTIVE_RECORD = null;

        async function getUserMediaStream() {
            return navigator.mediaDevices?.getUserMedia
                ? navigator.mediaDevices.getUserMedia({ audio: true })
                : Promise.reject(new Error('getUserMedia not supported'));
        }

        async function startRecording(phraseId, btnRecord, btnPlay) {
            if (ACTIVE_RECORD) await stopRecording();
            let stream;
            try { stream = await getUserMediaStream(); }
            catch (e) { alert('Microphone permission is needed for recording.'); return; }

            const chunks = [];
            const mimeCandidates = ['audio/webm;codecs=opus', 'audio/webm', 'audio/mp4', 'audio/ogg;codecs=opus'];
            const selectedMime = mimeCandidates.find(t => { try { return MediaRecorder.isTypeSupported(t); } catch { return false; } }) || '';
            const mr = selectedMime ? new MediaRecorder(stream, { mimeType: selectedMime }) : new MediaRecorder(stream);

            ACTIVE_RECORD = { phraseId, mediaRecorder: mr, chunks, btnRecord, btnPlay };

            btnRecord.textContent = 'Stop';
            btnRecord.classList.add('primary');
            btnRecord.setAttribute('aria-busy', 'true');

            mr.addEventListener('dataavailable', e => { if (e.data && e.data.size) chunks.push(e.data); });
            mr.addEventListener('stop', () => {
                const blob = new Blob(chunks, { type: selectedMime || 'audio/webm' });

                const prev = RECORDINGS.get(phraseId);
                if (prev?.url) { try { URL.revokeObjectURL(prev.url); } catch { } }

                const url = URL.createObjectURL(blob);
                RECORDINGS.set(phraseId, { url, blob });

                btnPlay.disabled = false;
                btnRecord.textContent = 'Record attempt';
                btnRecord.classList.remove('primary');
                btnRecord.removeAttribute('aria-busy');

                stream.getTracks().forEach(t => t.stop());
                ACTIVE_RECORD = null;
            });

            mr.start();
        }

        async function stopRecording() {
            if (!ACTIVE_RECORD) return;
            try { ACTIVE_RECORD.mediaRecorder.stop(); } catch { }
        }

        function playMyRecording(phraseId, btn) {
            const rec = RECORDINGS.get(phraseId);
            if (!rec?.url) return;

            stopCurrentAudio();
            const audio = new Audio(rec.url);
            CURRENT_AUDIO = audio;
            CURRENT_BTN = btn || null;

            if (CURRENT_BTN) {
                CURRENT_BTN.classList.add('playing');
                CURRENT_BTN.setAttribute('aria-busy', 'true');
            }

            audio.addEventListener('ended', stopCurrentAudio, { once: true });
            audio.addEventListener('error', stopCurrentAudio, { once: true });

            audio.play();
        }

        // =========================
        // Views / Rendering
        // =========================
        const $ = sel => document.querySelector(sel);

        function showView(name) {
            const views = ["categories", "phrases"];
            views.forEach(v => {
                const el = document.getElementById(`view-${v}`);
                if (!el) return;
                const on = (v === name);
                el.hidden = !on;
                el.classList.toggle('active', on);
            });
            if (name === "categories") { window.scrollTo({ top: 0, behavior: 'instant' }); }
        }

        function renderCategories() {
            const ul = $("#categoryList");
            ul.innerHTML = "";

            // Regular categories
            (MAPPING.categories || []).forEach(cat => {
                const count = (MAPPING.phrases?.[cat.id] || []).length;
                const li = document.createElement('li');
                li.innerHTML = `<span class="category-name">${cat.name}</span>
                        <span class="category-count">${count} phrase${count === 1 ? "" : "s"}</span>`;
                li.addEventListener('click', () => openCategory(cat.id, cat.name));
                ul.appendChild(li);
            });

            // Tone Guide card at bottom (whole tile clickable) — build with nodes (no innerHTML)
            try {
                const toneLi = document.createElement('li');
                toneLi.className = 'tone-guide-card';

                const name = document.createElement('span');
                name.className = 'category-name';
                name.textContent = 'Tone Guide';

                const br = document.createElement('br');

                const count = document.createElement('span');
                count.className = 'category-count';
                count.textContent = 'Quick refresher on Vietnamese tones';

                toneLi.appendChild(name);
                toneLi.appendChild(br);
                toneLi.appendChild(count);

                toneLi.addEventListener('click', () => { window.location.href = 'tone-guide.html'; });

                ul.appendChild(toneLi);
            } catch (e) {
                console.error('Failed to append Tone Guide tile:', e);
            }
        }

        function openCategory(catId, catName) {
            $("#phrasesCategoryTitle").textContent = catName;
            const container = $("#phrasesContainer");
            container.innerHTML = "";

            const items = (MAPPING.phrases?.[catId] || []);
            items.forEach(item => {
                // item: { id, vi, en, syllables:[{ id, text, tone }] }
                const card = document.createElement('div');
                card.className = 'phrase-card';

                // Translation (EN) first
                const tr = document.createElement('div');
                tr.className = 'translation';
                tr.textContent = item.en;

                // Top row: phrase play + Vietnamese text
                const top = document.createElement('div');
                top.className = 'phrase-top';

                const btnPhrase = document.createElement('button');
                btnPhrase.className = 'audio-btn primary';
                btnPhrase.textContent = '▶︎';
                btnPhrase.setAttribute('data-id', item.id);
                btnPhrase.addEventListener('click', () => playById(item.id, btnPhrase));

                const phraseText = document.createElement('div');
                phraseText.innerHTML = `<strong>${item.vi}</strong>`;

                top.appendChild(btnPhrase);
                top.appendChild(phraseText);

                // Syllables row (entire tile is tappable; tiny ▶︎ hint)
                const row = document.createElement('div');
                row.className = 'syllable-row';
                (item.syllables || []).forEach(syl => {
                    const wrap = document.createElement('div');
                    wrap.className = 'syllable';
                    wrap.setAttribute('role', 'button');
                    wrap.setAttribute('tabindex', '0');
                    wrap.setAttribute('data-id', syl.id);

                    const head = document.createElement('div');
                    head.className = 'syllable-head';

                    const sylText = document.createElement('div');
                    sylText.className = 'syllable-text';
                    sylText.textContent = syl.text;

                    const hint = document.createElement('span');
                    hint.className = 'play-hint';
                    hint.textContent = '▶︎';

                    const tone = document.createElement('div');
                    tone.className = 'tone-name';
                    tone.textContent = syl.tone;

                    head.appendChild(sylText);
                    head.appendChild(hint);
                    wrap.appendChild(head);
                    wrap.appendChild(tone);

                    const playSyl = () => playById(syl.id, wrap);
                    wrap.addEventListener('click', playSyl);
                    wrap.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            playSyl();
                        }
                    });

                    row.appendChild(wrap);
                });

                // Controls — Record & Compare (phrase-level)
                const controls = document.createElement('div');
                controls.className = 'controls';

                const btnRecord = document.createElement('button');
                btnRecord.className = 'btn';
                btnRecord.textContent = 'Record attempt';
                btnRecord.title = 'Record attempt (temporary, not saved)';

                const btnMy = document.createElement('button');
                btnMy.className = 'btn my-attempt';
                btnMy.textContent = 'Play attempt';
                btnMy.title = 'Play your last attempt for this phrase';
                btnMy.disabled = !RECORDINGS.get(item.id);

                btnRecord.addEventListener('click', async () => {
                    if (ACTIVE_RECORD && ACTIVE_RECORD.phraseId === item.id) {
                        await stopRecording();
                    } else {
                        if (ACTIVE_RECORD) await stopRecording();
                        startRecording(item.id, btnRecord, btnMy);
                    }
                });

                btnMy.addEventListener('click', () => playMyRecording(item.id, btnMy));

                // “Check Tone” placeholder — show “Coming soon!”
                const btnCheck = document.createElement('button');
                btnCheck.className = 'btn ghost';
                btnCheck.textContent = 'Check Tone';
                btnCheck.addEventListener('click', () => alert('Coming soon!'));

                controls.append(btnRecord, btnMy, btnCheck);

                // Assemble card
                card.appendChild(tr);
                card.appendChild(top);
                card.appendChild(row);
                card.appendChild(controls);

                container.appendChild(card);
            });

            // After rendering a new list, reattach press feedback handlers
            attachPressFeedback(container);

            showView('phrases');
        }

        // ——— Press feedback helper ———
        function attachPressFeedback(root = document) {
            const pressables = root.querySelectorAll('.btn, .audio-btn, .syllable');
            pressables.forEach(el => {
                const onDown = () => el.classList.add('is-pressed');
                const onUp = () => el.classList.remove('is-pressed');

                el.addEventListener('mousedown', onDown);
                el.addEventListener('mouseup', onUp);
                el.addEventListener('mouseleave', onUp);

                el.addEventListener('touchstart', onDown, { passive: true });
                el.addEventListener('touchend', onUp, { passive: true });
                el.addEventListener('touchcancel', onUp, { passive: true });
            });
        }

        // ——— Wiring: nav + init ———
        document.getElementById('btnBackToCategories').addEventListener('click', () => showView('categories'));

        // Boot
        (async function start() {
            await initMapping();
            renderCategories();
            attachPressFeedback(document);
            showView('categories'); // categories-first
        })();
    </script>
</body>

</html>